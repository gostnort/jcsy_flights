# JSCY Format Configuration
# This file defines how to parse JSCY formatted data

format_version: "1.0"

# Header line format
header:
  pattern: "^JCSY:"  # Pattern to identify header lines like "JCSY:CA0984/17APR/LAX,I"
  fields:
    - name: flight_info
      position: [5, -1]  # Take everything after "JCSY:"
      type: special
      parser: parse_jscy_header

# Flight line format (updated for single airport format)
flight:
  pattern: "^[A-Z]{2}\\d+"  # Pattern to identify flight lines like "UA2449 /ORD..."
  fields:
    - name: airline
      position: [0, 2]
      type: string
    
    - name: flight_number
      position: [2, 6]
      type: string
      transform: trim_leading_zeros
    
    - name: airport_info
      position: [7, 20]  # This range should capture "/ORD" with variable spacing
      type: special
      parser: parse_airport_info
      
    - name: booked_count_non_economy
      position: [20, 26]  # Adjusted based on example line
      type: integer
      default: 0
    
    - name: booked_count_economy
      position: [27, 33]  # Adjusted based on example line 
      type: integer
      default: 0
    
    - name: checked_count_non_economy
      position: [34, 41]  # Adjusted based on example line
      type: integer
      default: 0
    
    - name: checked_count_economy
      position: [42, 50]  # Adjusted based on example line
      type: integer
      default: 0
    
    - name: check_count_infant
      position: [51, 54]  # Adjusted based on example line
      type: integer
      default: 0
    
    - name: bags_count_piece
      position: [55, 58]  # Adjusted based on example line
      type: integer
      default: 0
    
    - name: bags_count_weight
      position: [59, 63]  # Adjusted based on example line
      type: float
      default: 0.0

# Special parsers for complex formats
special_parsers:
  parse_jscy_header:
    description: "Parse JSCY header like CA0984/17APR/LAX,I"
    python: |
      def parse_jscy_header(value):
          from datetime import datetime
          import re
          result = {}
          
          # Split by components
          parts = value.split('/')
          if len(parts) < 2:
              return result
              
          # Extract flight number and airline
          flight_part = parts[0]
          if re.match(r'^[A-Z]{2}\d+', flight_part):
              result['airline'] = flight_part[0:2]
              result['flight_number'] = flight_part[2:].lstrip('0')
          
          # Extract date
          if len(parts) > 1:
              date_part = parts[1]
              current_year = datetime.now().year
              
              # Handle date format with or without year
              try:
                  if len(date_part) <= 5:  # Format like 17APR
                      date_obj = datetime.strptime(date_part, '%d%b')
                      date_obj = date_obj.replace(year=current_year)
                  else:  # Format like 17APR25
                      date_obj = datetime.strptime(date_part, '%d%b%y')
                  
                  result['flight_date'] = date_obj.strftime('%Y%m%d')
              except ValueError:
                  pass
          
          # Extract airport and arrival indicator
          if len(parts) > 2:
              last_part = parts[2]
              header_airport = None
              is_arrival = False
              
              if ',' in last_part:
                  airport, indicator = last_part.split(',', 1)
                  header_airport = airport.strip()
                  is_arrival = indicator.strip() == 'I'
              else:
                  header_airport = last_part.strip()
                  is_arrival = False  # Default to departure
              
              # Store the header airport and arrival status
              result['header_airport'] = header_airport
              result['is_arrival'] = is_arrival
          
          return result
          
  parse_airport_info:
    description: "Parse airport information from flight line"
    python: |
      def parse_airport_info(value):
          import re
          result = {}
          
          # Extract airport code (after slash, before spaces)
          airport_match = re.search(r'/([A-Z]{3})', value)
          if airport_match:
              airport = airport_match.group(1)
              result['flight_line_airport'] = airport
          
          # Extract time if present (4 digits after airport)
          time_match = re.search(r'/[A-Z]{3}\s+(\d{4})', value)
          if time_match:
              time_value = time_match.group(1)
              # Format time as HH:MM
              if len(time_value) == 4:
                  # Always treat time as STD regardless of arrival/departure
                  result['std'] = f"{time_value[:2]}:{time_value[2:]}"
          
          return result

# Transforms that can be applied to fields
transforms:
  trim_leading_zeros:
    description: "Remove leading zeros from a string"
    python: "lambda x: x.lstrip('0') if x and x.strip('0') else '0'"
  
  to_uppercase:
    description: "Convert string to uppercase"
    python: "lambda x: x.upper()"

# Field types and their conversion functions
types:
  string:
    python: "lambda x: x.strip()"
  
  integer:
    python: "lambda x: int(x.strip()) if x.strip() else 0"
  
  float:
    python: "lambda x: float(x.strip()) if x.strip() else 0.0"
  
  date:
    python: "lambda x, fmt: datetime.strptime(x, fmt).strftime('%Y%m%d')"
  
  boolean:
    python: "lambda x, mapping: mapping.get(x, False)"
  
  special:
    python: "lambda x, parser_name: special_parsers[parser_name](x)" 